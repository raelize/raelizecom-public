<!DOCTYPE html>
<html lang="en"><meta charset="utf-8"><meta name="generator" content="Hugo 0.75.1" /><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="color-scheme" content="light dark">
<meta name="supported-color-schemes" content="light dark"><title>Espressif ESP32: Bypassing Encrypted Secure Boot (CVE-2020-13629)&nbsp;&ndash;&nbsp;</title><link rel="stylesheet" href="/css/core.min.0b9416c1ab7ad80e65b9c8c02a08c0bc1ccc6239d624b16fd01f9ec0d401727ffe61878c75525c2bb300f182d0c722f2.css" integrity="sha384-C5QWwat62A5lucjAKgjAvBzMYjnWJLFv0B&#43;ewNQBcn/&#43;YYeMdVJcK7MA8YLQxyLy"><meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="Espressif ESP32: Bypassing Encrypted Secure Boot (CVE-2020-13629)" /><body><section id="header">
    <div class="header wrap"><span class="header left-side"><a class="site home" href="/"><img class="site logo" src="/img/logo.png" alt /><span class="site name"></span></a></span>
        <span class="header right-side"><div class="nav wrap"><nav class="nav"><a class="nav item" href="/">Home</a><a class="nav item" href="/about">About</a><a class="nav item" href="/services">Services</a><a class="nav item" href="/training">Training</a><a class="nav item" href="/blog">Blog</a><a class="nav item" href="/contact">Contact</a></nav></div></span></div></section><section id="content"><div class="article-container"><section class="article header">
    <h1 class="article title">Espressif ESP32: Bypassing Encrypted Secure Boot (CVE-2020-13629)</h1><p class="article date">Tuesday, September 22, 2020</p></section><article class="article markdown-body"><p>We arrived at the last post about our <strong>Fault Injection</strong> research on the <strong>ESP32</strong>. Please read our previous posts as it provides context to the results described in this post.</p>
<ul>
<li><a href="/posts/espressif-systems-esp32-bypassing-sb-using-emfi/">Espressif ESP32: Bypassing Secure Boot using EMFI</a></li>
<li><a href="/posts/espressif-systems-esp32-controlling-pc-during-sb/">Espressif ESP32: Controlling PC during Secure Boot</a></li>
<li><a href="/posts/espressif-systems-esp32-bypassing-flash-encryption/">Espressif ESP32: Bypassing Flash Encryption (CVE-2020-15048)</a></li>
</ul>
<p>During our <strong>Fault Injection</strong> research on the <strong>ESP32</strong>, we gradually took steps forward in order to identify the required vulnerabilities that allowed us to bypass <strong>Secure Boot</strong> and <strong>Flash Encryption</strong> with a single <strong>EM</strong> glitch. Moreover, we did not only achieve <strong>code execution</strong>, we also extracted the <strong>plain-text flash</strong> data from the chip.</p>
<p><strong>Espressif</strong> requested a <strong>CVE</strong>  for the attack described in this post: <a href="https://www.espressif.com/sites/default/files/advisory_downloads/Security%20Advisory%20CVE-2020-15048%2C%2013629%20EN%26CN.pdf"target="_blank">CVE-2020-13629</a>. Please note, that the attack as described in this post, is only applicable to <strong>ESP32</strong> silicon revision 0 and 1. The newer <strong>ESP32 V3</strong> silicon supports functionality to disable the <strong>UART bootloader</strong> that we leveraged for the attack.</p>
<h1 id="uart-bootloader">UART bootloader</h1>
<p>The <strong>ESP32</strong> implements an <strong>UART bootloader</strong> in its <strong>ROM code</strong>. This feature allows, among other functionality, to program the external flash. It's not uncommon that such functionality is implemented in the <strong>ROM code</strong> as it's quite robust as the code cannot get corrupt easily. If this functionality would be implemented by code stored in the external flash, any corruption of the flash may result in a bricked device.</p>
<p>Typically, this type of functionality is accessed by booting the chip in a special <strong>boot mode</strong>. The <strong>boot mode</strong> selection is often done using one or more external strap pin(s) which are set before resetting the chip. On the <strong>ESP32</strong> it works exactly like this pin <code>G0</code> which is exposed externally.</p>
<p>The <strong>UART bootloader</strong> supports many interesting <a href="https://github.com/espressif/esptool/wiki/Serial-Protocol#command-opcodes"target="_blank">commands</a> that can be used to read/write memory, read/write registers and even execute a stub from <strong>SRAM</strong>.</p>
<h4 id="executing-arbitrary-code">Executing arbitrary code</h4>
<p>The <strong>UART bootloader</strong> supports loading and executing arbitrary code using the <code>load_ram</code> command. The <strong>ESP32</strong>'s SDK includes all the tooling required to compile the code that can be executed from <strong>SRAM</strong>. For example, the following code snippet will print <code>SRAM CODE\n</code> on the serial interface.</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">))</span> <span class="n">call_start_cpu0</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">ets_printf</span><span class="p">(</span><span class="s">&#34;SRAM CODE</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>The <code>esptool.py</code> tool, which is part of the <strong>ESP32</strong>'s SDK, can be used to load the compiled binary into the <strong>SRAM</strong> after which it will be executed.</p>
<pre><code>esptool.py --chip esp32 --no-stub --port COM3 load_ram code.bin
</code></pre><p>Interestingly, the <strong>UART bootloader</strong> cannot disabled and therefore always accessible, even when <strong>Secure Boot</strong> and <strong>Flash Encryption</strong> are enabled.</p>
<h4 id="additional-measures">Additional measures</h4>
<p>Obviously, if no additional security measures would be taken, leaving the <strong>UART bootloader</strong> always accessible would render <strong>Secure Boot</strong> and <strong>Flash Encryption</strong> likely useless. Therefore, <strong>Espressif</strong> implemented additional security measures which are enabled using dedicated <strong>eFuses</strong>.</p>
<p>These are security configuration bits implemented in special memory, often referred to as <strong>OTP memory</strong>, which can typically only change from 0 to 1. This guarantees, that once enabled, is enabled forever. The following <strong>OTP memory</strong> bits are used to disable specific functionality when the <strong>ESP32</strong> is in the <strong>UART bootloader</strong> boot mode.</p>
<ul>
<li><strong>DISABLE_DL_ENCRYPT</strong>: disables flash encryption operation</li>
<li><strong>DISABLE_DL_DECRYPT</strong>: disables transparent flash decryption</li>
<li><strong>DISABLE_DL_CACHE</strong>: disables the entire MMU flash cache</li>
</ul>
<p>The most relevant <strong>OTP memory</strong> bit is <strong>DISABLE_DL_DECRYPT</strong> as it disables the transparent decryption of the flash data.</p>
<p>If not set, it would be possible to simply access the plain-text flash data while the <strong>ESP32</strong> is in its <strong>UART bootloader</strong> boot mode.</p>
<p>If set, any access to the flash, when the chip is in <strong>UART bootloader</strong> boot mode, will yield just the encrypted data. The <strong>Flash Encryption</strong> feature, which is fully implemented in hardware and transparent to the processor,  is only enabled in when the <strong>ESP32</strong> is in <strong>Normal</strong> boot mode.</p>
<p>The attacks described in this post have all these bits set to 1.</p>
<h1 id="persistent-data-in-sram">Persistent data in SRAM</h1>
<p>The <strong>SRAM</strong> memory that's used by the <strong>ESP32</strong> is typical technology that's used by many chips. It's commonly used to the <strong>ROM</strong>'s stack and executing the first bootloader from flash. It's convenient to use at early boot as it typically require no configuration before it can be used.</p>
<p>We know from previous experience that the data stored in <strong>SRAM</strong> memory is persistent until it's overwritten or the required power is removed from the physical cells. After a <strong>cold reset</strong> (i.e. power-cycle) of the chip, the <strong>SRAM</strong> will be reset to its default state. This often semi-random and unique per chip as the default value for each bit (i.e. 0 or 1) is different.</p>
<p>However, after a <strong>warm reset</strong>, where the entire chip is reset without removing the power, it may happen that the data stored in <strong>SRAM</strong> remains unaffected. This persistence of the data is visualized in the picture below.</p>
<p style="text-align:center;">
    <a href="/img/esp32/esp32-sram-persistence.png">
        <img src="/img/esp32/esp32-sram-persistence.png" width="700px">
    </a>
</p>
<p>We decided to figure out if this behavior holds up for the <strong>ESP32</strong> as well. We identified that the hardware <a href="https://docs.espressif.com/projects/esp-idf/en/latest/esp32/api-reference/system/wdts.html"target="_blank">watchdog</a> can be used to issue a <strong>warm reset</strong> from software. This <strong>watchdog</strong> can also be issued when the chip is in <strong>UART bootloader</strong> boot mode and therefore we can use it to reset the <strong>ESP32</strong> back into <strong>Normal</strong> boot mode.</p>
<p>Using some test code, loaded and executed in <strong>SRAM</strong> using the <strong>UART bootloader</strong>, we determined that the data in <strong>SRAM</strong> is indeed persistent after issuing a <strong>warm reset</strong> using the <strong>watchdog</strong>. Effectively this means we can boot the <strong>ESP32</strong> in <strong>Normal</strong> boot mode with the <strong>SRAM</strong> filled with controlled data.</p>
<p>But&hellip; how can we (ab)use this?</p>
<h1 id="road-to-failure">Road to failure</h1>
<p>We envisioned that we may be able to leverage the persistence of data in <strong>SRAM</strong> across <strong>warm resets</strong> for an attack. The first attack we came up with is to fill the <strong>SRAM</strong> with code using the <strong>UART bootloader</strong> and issue a <strong>warm reset</strong> using the <strong>watchdog</strong>. Then, we inject a glitch while the <strong>ROM code</strong> is overwriting this code with the <strong>flash bootloader</strong> during a normal boot.</p>
<p>We got this ideas as during our previous experiments, where we <a href="">turned data transfers into code execution</a>, we noticed that for some experiments the chip started executing from the entry address before the bootloader was finished copying.</p>
<p>Sometimes you just need to try it&hellip;</p>
<h4 id="attack-code">Attack code</h4>
<p>The code that we load into the <strong>SRAM</strong> using the <strong>UART bootloader</strong> is shown below.</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define a &#34;addi a6, a6, 1;&#34;
</span><span class="cp">#define t a a a a a a a a a a
</span><span class="cp">#define h t t t t t t t t t t
</span><span class="cp">#define d h h h h h h h h h h
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">))</span> <span class="n">call_start_cpu0</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">uint8_t</span> <span class="n">cmd</span><span class="p">;</span>

    <span class="n">ets_printf</span><span class="p">(</span><span class="s">&#34;SRAM CODE</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">cmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">uart_rx_one_char</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="sc">&#39;A&#39;</span><span class="p">)</span> <span class="p">{</span>                                    <span class="c1">// 1
</span><span class="c1"></span>            <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="mh">0x3ff4808c</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x4001f880</span><span class="p">;</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="mh">0x3ff48090</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x00003a98</span><span class="p">;</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="mh">0x3ff4808c</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0xc001f880</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">asm</span> <span class="k">volatile</span> <span class="p">(</span> <span class="n">d</span> <span class="p">);</span>                                     <span class="c1">// 2
</span><span class="c1"></span>
    <span class="s">&#34;movi a6, 0x40; slli a6, a6, 24;&#34;</span>                       <span class="c1">// 3
</span><span class="c1"></span>    <span class="s">&#34;movi a7, 0x00; slli a7, a7, 16;&#34;</span>
    <span class="s">&#34;xor a6, a6, a7;&#34;</span>
    <span class="s">&#34;movi a7, 0x7c; slli a7, a7, 8;&#34;</span>
    <span class="s">&#34;xor a6, a6, a7;&#34;</span>
    <span class="s">&#34;movi a7, 0xf8;&#34;</span>
    <span class="s">&#34;xor a6, a6, a7;&#34;</span>

    <span class="s">&#34;movi a10, 0x52; callx8  a6;&#34;</span> <span class="c1">// R
</span><span class="c1"></span>    <span class="s">&#34;movi a10, 0x61; callx8  a6;&#34;</span> <span class="c1">// a            
</span><span class="c1"></span>    <span class="s">&#34;movi a10, 0x65; callx8  a6;&#34;</span> <span class="c1">// e               
</span><span class="c1"></span>    <span class="s">&#34;movi a10, 0x6C; callx8  a6;&#34;</span> <span class="c1">// l               
</span><span class="c1"></span>    <span class="s">&#34;movi a10, 0x69; callx8  a6;&#34;</span> <span class="c1">// i               
</span><span class="c1"></span>    <span class="s">&#34;movi a10, 0x7A; callx8  a6;&#34;</span> <span class="c1">// z               
</span><span class="c1"></span>    <span class="s">&#34;movi a10, 0x65; callx8  a6;&#34;</span> <span class="c1">// e               
</span><span class="c1"></span>    <span class="s">&#34;movi a10, 0x21; callx8  a6;&#34;</span> <span class="c1">// !               
</span><span class="c1"></span>    <span class="s">&#34;movi a10, 0x0a; callx8  a6;&#34;</span> <span class="c1">// \n               
</span><span class="c1"></span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>To summarize, the above code implements the following:</p>
<ol>
<li>Command handler with a single command to perform a <strong>watchdog</strong> reset</li>
<li>NOP-like padding using <code>addi</code> instructions</li>
<li>Assembly for printing <code>Raelize!</code> on the serial interface</li>
</ol>
<p>Please note, the listing's numbers match the numbers in the code.</p>
<h4 id="timing">Timing</h4>
<p>We target a reasonably small attack window at the start of <strong>F</strong> which is shown in the picture below. We know from previous experiments that during this moment the <strong>flash bootloader</strong> is copied.</p>
<p style="text-align:center;">
    <a href="/img/esp32/esp32-spi-pin1-during-boot.png">
        <img src="/img/esp32/esp32-spi-pin1-during-boot.png" width="600px">
    </a>
</p>
<p>The glitch must be injected before our code in <strong>SRAM</strong> is entirely overwritten by the valid <strong>flash bootloader</strong>.</p>
<h4 id="attack-cycle">Attack cycle</h4>
<p>We took the following steps for each experiment to determine if the attack idea actually works. A successful glitch will print <code>Raelize!</code> on the serial interface.</p>
<ol>
<li>Set pin <strong>G0</strong> to low and perform a <strong>cold reset</strong> to enter <strong>UART bootloader</strong> boot mode</li>
<li>Use the <code>load_ram</code> command to execute our <strong>attack code</strong> from <strong>SRAM</strong></li>
<li>Send an <code>A</code> to the program to issue a <strong>warm reset</strong> into <strong>normal</strong> boot mode</li>
<li>Inject a glitch while the <strong>flash bootloader</strong> is being copied by the <strong>ROM code</strong></li>
</ol>
<h4 id="results">Results</h4>
<p>After running these experiments for more than a day, resulting in more than 1 million experiments, we did not observe any successful glitch&hellip;</p>
<h4 id="an-unexpected-result">An unexpected result</h4>
<p>Nonetheless, while analyzing the results, we noticed something unexpected.</p>
<p>The <strong>serial interface</strong> output for one of the experiments, which is shown below, indicated that the glitch caused an <strong>illegal instruction</strong> exception.</p>
<pre><code>ets Jun  8 2016 00:22:57
rst:0x10 (RTCWDT_RTC_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
configsip: 0, SPIWP:0xee
clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
mode:DIO, clock div:2
load:0x3fff0008,len:4
load:0x3fff000c,len:3220
load:0x40078000,len:4816
load:0x40080400,len:18640
entry 0x40080740
Fatal exception (0): IllegalInstruction
epc1=0x661b661b, epc2=0x00000000, epc3=0x00000000, 
excvaddr=0x00000000, depc=0x00000000
</code></pre><p>These type of exceptions happened quite often when glitches are injected in a chip. This was not different for the <strong>ESP32</strong>. For most the exceptions the <code>PC</code> register is set to a value that's expected (i.e. a valid address). It does not happen often the <code>PC</code> register is set to such an interesting value.</p>
<p>The <code>Illegal Instruction</code> exception is caused as there is no valid instruction stored at the <code>0x661b661b</code> address. We conclude this value must come from somewhere and that is cannot magically end up in the <code>PC</code> register.</p>
<p>We analyzed the code that we load into the <strong>SRAM</strong> in order to find an explanation. The binary code, of which a snippet is shown below, quickly gave us the answer we were looking for. The value <code>0x661b661b</code> is easily identified in the above binary image. It actually represents two <code>addi a6, a6, 1</code> instructions of which we implemented 1000 in our test code.</p>
<pre><code>00000000  e9 02 02 10 28 04 08 40  ee 00 00 00 00 00 00 00  |....(..@........|
00000010  00 00 00 00 00 00 00 01  00 00 ff 3f 0c 00 00 00  |...........?....|
00000020  53 52 41 4d 20 43 4f 44  45 0a 00 00 00 04 08 40  |SRAM CODE......@|
00000030  50 09 00 00 00 00 ff 3f  04 04 fe 3f 4d 04 08 40  |P......?...?M..@|
00000040  00 04 fe 3f 8c 80 f4 3f  90 80 f4 3f 98 3a 00 00  |...?...?...?.:..|
00000050  80 f8 01 c0 54 7d 00 40  d0 92 00 40 36 61 00 a1  |....T}.@...@6a..|
00000060  f5 ff 81 fc ff e0 08 00  0c 08 82 41 00 ad 01 81  |...........A....|
00000070  fa ff e0 08 00 82 01 00  4c 19 97 98 1f 81 ef ff  |........L.......|
00000080  91 ee ff 89 09 91 ee ff  89 09 91 f0 ff 81 ee ff  |................|
00000090  99 08 91 ef ff 81 eb ff  99 08 86 f2 ff 5c a9 97  |.............\..|
000000a0  98 c5 1b 66 1b 66 1b 66  1b 66 1b 66 1b 66 3e 0c  |...f.f.f.f.f.f&gt;.|
000000b0  1b 66 1b 66 1b 66 1b 66  1b 66 1b 66 1b 66 1b 66  |.f.f.f.f.f.f.f.f|
000000c0  1b 66 1b 66 1b 66 1b 66  1b 66 1b 66 1b 66 1b 66  |.f.f.f.f.f.f.f.f|
000000d0  1b 66 1b 66 1b 66 1b 66  1b 66 1b 66 1b 66 1b 66  |.f.f.f.f.f.f.f.f|
...
00000330  1b 66 1b 66 1b 66 1b 66  1b 66 1b 66 1b 66 1b 66  |.f.f.f.f.f.f.f.f|
00000340  1b 66 1b 66 1b 66 1b 66  1b 66 1b 66 1b 66 1b 66  |.f.f.f.f.f.f.f.f|
00000350  1b 66 1b 66 1b 66 1b 66  1b 66 1b 66 1b 66 1b 66  |.f.f.f.f.f.f.f.f|
</code></pre><p>We just use these instructions as <code>NOPs</code> in order to create a landing zone in a similar fashion a <strong>NOP-sled</strong> is often used in software exploits. We did not anticipate these instructions would end up in the <code>PC</code> register.</p>
<p>Of course, we did not mind either. We concluded that, we are able to load data from <strong>SRAM</strong> into the <code>PC</code> register when we inject a glitch while the <strong>flash bootloader</strong> is being copied by the <strong>ROM code</strong> .</p>
<p>We quickly realized, we now have all the ingredients to cook up an attack where we bypass <strong>Secure Boot</strong> and <strong>Flash Encryption</strong> using a single glitch. We reused some of the knowledge obtained during a <a href="/posts/espressif-systems-esp32-controlling-pc-during-sb/">previously described attack</a> where we take control of the <code>PC</code> register.</p>
<h1 id="road-to-success">Road to success</h1>
<p>We reused most of the code that we previously loaded into <strong>SRAM</strong> using the <strong>UART bootloader</strong>. Only the payload (i.e. printing) that we intended to execute is removed as our strategy is now to set the <code>PC</code> register to an arbitrary value in order to take control.</p>
<div class="highlight"><pre class="chroma"><code class="language-C" data-lang="C"><span class="cp">#define a &#34;addi a6, a6, 1;&#34;
</span><span class="cp">#define t a a a a a a a a a a
</span><span class="cp">#define h t t t t t t t t t t
</span><span class="cp">#define d h h h h h h h h h h
</span><span class="cp"></span>
<span class="kt">void</span> <span class="nf">__attribute__</span><span class="p">((</span><span class="n">noreturn</span><span class="p">))</span> <span class="n">call_start_cpu0</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">uint8_t</span> <span class="n">cmd</span><span class="p">;</span>
   
    <span class="n">ets_printf</span><span class="p">(</span><span class="s">&#34;SRAM CODE</span><span class="se">\n</span><span class="s">&#34;</span><span class="p">);</span>

    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>

        <span class="n">cmd</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">uart_rx_one_char</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cmd</span><span class="p">);</span>

        <span class="k">if</span><span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="sc">&#39;A&#39;</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="mh">0x3ff4808c</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x4001f880</span><span class="p">;</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="mh">0x3ff48090</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0x00003a98</span><span class="p">;</span>
            <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)(</span><span class="mh">0x3ff4808c</span><span class="p">)</span> <span class="o">=</span> <span class="mh">0xc001f880</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">asm</span> <span class="k">volatile</span> <span class="p">(</span> <span class="n">d</span> <span class="p">);</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div><p>After compiling the above code, we overwrite directly in the binary the <code>addi</code> instructions with the address pointer <code>0x4005a980</code>. This address points to a function in the <strong>ROM code</strong> that prints something on the <strong>serial interface</strong>. This allows us to identify when we are successful.</p>
<p>We fixed the <strong>glitch parameters</strong> to that of the experiment that caused the <code>Illegal Instruction</code> exception. After a short while, we successfully identified several experiments during which the address pointer is loaded into the <code>PC</code> register. Effectively this provides us with control of the <code>PC</code> register and we can likely achieve arbitrary code execution.</p>
<h4 id="why-does-this-work">Why does this work?</h4>
<p>Good question. Not so easy to answer.</p>
<p>Unfortunately, we do not have a sound answer for you. We definitely did not anticipate that controlling the data at the destination could yield control of the <code>PC</code> register. We came up with a few possibilities, but we cannot say with full confidence if any of these is actually correct.</p>
<p>One explanation is that the glitch may corrupt both operands of the <code>ldr</code> instruction in order to load a value from the destination into the <code>a0</code>. This is similar as the <a href="/posts/espressif-systems-esp32-controlling-pc-during-sb/">previously described attack</a> where we control <code>PC</code> indirectly by controlling the source data.</p>
<p>Moreover, it's a possibility that the <strong>ROM code</strong> implements functionality that facilitates this attack. In other words, we may execute valid code within the <strong>ROM</strong> due to our glitch that causes the value from <strong>SRAM</strong> to be loaded into the <code>PC</code> register.</p>
<p>More thorough investigation is required in order to determine what exactly allows us to perform this attack. However, from an attacker's perspective, it's sufficient to realize how to get control of <code>PC</code> in order to build the exploit.</p>
<h1 id="extracting-plain-text-data">Extracting plain-text data</h1>
<p>Even though we have control of the <code>PC</code> register, we are not yet able to extract the plain-text data from the flash. We decided to leverage the <strong>UART bootloader</strong> functionality to do so.</p>
<p>We decided to jump directly to the <strong>UART bootloader</strong> while the chip is in <strong>Normal</strong> boot mode. For this attack we overwrite the <code>addi</code> instructions in the code that we load into <strong>SRAM</strong> with address pointers to the start of the <strong>UART bootloader</strong> (<code>0x0x40007a19</code>).</p>
<p>The <strong>UART bootloader</strong> prints a string on the <strong>serial interface</strong> which is shown below. We can use this to identify if we are successful or not.</p>
<pre><code>waiting for download\n&quot;
</code></pre><p>Once we observe a successful experiment, we can simply use the <code>esptool.py</code> to issue a <code>read_mem</code> command in order to access plain-text flash data. The command below reads 4 bytes from the address where the external flash is mapped (<code>0x3f400000</code>).</p>
<pre><code>esptool.py --no-stub --before no_reset --after no_reset read_mem 0x3f400000
</code></pre><p>Unfortunately, this did not work. For some reason the processor is replying with <code>0xbad00bad</code> which is an indication we read from an unmapped page.</p>
<pre><code>esptool.py v2.8
Serial port COM8
Connecting....
Detecting chip type... ESP32
Chip is ESP32D0WDQ6 (revision 1)
Crystal is 40MHz
MAC: 24:6f:28:24:75:08
Enabling default SPI flash mode...
0x3f400000 = 0xbad00bad
Staying in bootloader.
</code></pre><p>We noticed that there is quite some configuration done at the start of the <strong>UART bootloader</strong>. We assume it may affect the <code>MMU</code> as well.</p>
<p>Just to try something different, we decided to jump directly to the command handler of the <strong>UART bootloader</strong> itself (<code>0x40007a4e</code>). Once in the hander, we can send a raw <code>read_mem</code> command directly on the <strong>serial interface</strong> which is shown below.</p>
<pre><code>target.write(b'\xc0\x00\x0a\x04\x00\x00\x00\x00\x00\x00\x00\x40\x3f\xc0')
</code></pre><p>Unfortunately, by jumping directly to the handler, the string that's printed (i.e. <code>waiting for download\n&quot;</code>) is not printed anymore. Therefore, we cannot easily identify successful experiments. Therefore, we decided to simply always send the command, regardless if we are successful or not. We used a very short <strong>serial interface</strong> timeout in order to minimize the overhead of almost always hitting the timeout.</p>
<p>After a short while, we observed the first successful experiments!</p>
<h1 id="conclusion">Conclusion</h1>
<p>In this post we described an attack on the <strong>ESP32</strong> where we bypass its <strong>Secure Boot</strong> and <strong>Flash Encryption</strong> features using a single <strong>EM glitch</strong>. Moreover, we leveraged the vulnerability exploited by this attack to extract the plain-text data from the encrypted flash.</p>
<p>We can use <a href="/posts/raelize-fi-reference-model/">FIRM</a> to break down the attack in multiple comprehensible stages.</p>
<p style="text-align:center;">
    <a href="/img/esp32/raelize-firm-esp32-nokey.png">
        <img src="/img/esp32/raelize-firm-esp32-nokey.png" width="800px">
    </a>
</p>
<p>Interestingly, two weaknesses of the <strong>ESP32</strong> facilitated this attack. First, the <strong>UART bootloader</strong> cannot be disabled and is always accessible. Second, the data loaded in <strong>SRAM</strong> is persistent across <strong>warm resets</strong> and can therefore be filled with arbitrary data using <strong>UART bootloader</strong>.</p>
<p>Espressif indicated in their <a href="https://www.espressif.com/sites/default/files/advisory_downloads/Security%20Advisory%20CVE-2020-15048%2C%2013629%20EN%26CN.pdf"target="_blank">advisory</a> related to this attack that newer versions of the <strong>ESP32</strong> include functionality to completely disable this feature.</p>
<h4 id="final-thoughts">Final thoughts</h4>
<p>All standard embedded technologies are vulnerable to <strong>Fault Injection</strong> attacks. Therefore, it's not surprising at all that the <strong>ESP32</strong> is vulnerable as well. These type of chips are simply not made to be resilient against these type of attacks. However, and this is important, this does not mean that these attacks do not impose a risk.</p>
<p>Our research has shown that leveraging chip-level weaknesses for <strong>Fault Injection</strong> attack is very effective. We have not seen many public examples yet as most attack still focus on traditional approaches where the focus is mostly on bypassing just a check.</p>
<p>We believe the full potential of <strong>Fault Injection</strong> attacks is still unexplored. Most research until recently focused mostly on the injection method itself (i.e. <strong>Activate</strong>, <strong>Inject</strong> and <strong>Glitch</strong>) compared to what can be accomplished due to a vulnerable chip (i.e. <strong>Fault</strong>, <strong>Exploit</strong> and <strong>Goal</strong>).</p>
<p style="text-align:center;">
    <a href="/img/esp32/raelize-firm-esp32-20202020.png">
        <img src="/img/esp32/raelize-firm-esp32-20202020.png" width="800px">
    </a>
</p>
<p>We are confident that creative usage of new and undefined fault models, will give rise to unforeseen attacks, where exciting exploitation strategies are used, for a wide variety of different goals.</p>
</article></div>
<div class="article bottom"><section class="article navigation"><p><a class="link" href="/posts/espressif-systems-esp32-bypassing-flash-encryption/"><span class="iconfont icon-article"></span>Espressif ESP32: Bypassing Flash Encryption (CVE-2020-15048)</a></p></section></div></section><section id="footer"><div class="footer-wrap">
    <p class="copyright">Â©2020 Raelize</p>
    <p class="powerby"><span>Powered by </span><a href="https://gohugo.io" 
        target="_blank">Hugo</a><span> and the </span><a href="https://themes.gohugo.io/hugo-notepadium/" 
        target="_blank">Notepadium</a></p>
</div></section>
<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)};ga.l=+new Date;
	ga('create', 'UA-135892271-3', 'auto');
	
	ga('send', 'pageview');
}
</script>
<script async src='https://www.google-analytics.com/analytics.js'></script>
</body>

</html>