<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="utf-8">
	<title>Qualcomm IPQ40xx: Achieving QSEE Code Execution</title>

	<!-- mobile responsive meta -->
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="description" content="Raelize provides top-notch embedded device security serrvices like consultancy, testing, research and training.">
	
	<meta name="author" content="Raelize B.V.">
	<meta name="generator" content="Hugo 0.148.2">

	<!-- plugins -->
	
	<link rel="stylesheet" href="https://raelize.com/plugins/bootstrap/bootstrap.min.css">
	
	<link rel="stylesheet" href="https://raelize.com/plugins/themify-icons/themify-icons.css">
	
	<link rel="stylesheet" href="https://raelize.com/plugins/magnific-popup/magnific-popup.css">
	
	<link rel="stylesheet" href="https://raelize.com/plugins/slick/slick.css">
	
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Anaheim%7cQuattrocento&#43;Sans:400,700&amp;display=swap">
	

	<!-- Main Stylesheet -->
	
	<link rel="stylesheet" href="https://raelize.com/css/style.min.css" media="screen">

	<!-- Custom stylesheet - for your changes -->
	
  <link rel="stylesheet" href="https://raelize.com/css/custom.min.css" media="screen">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://raelize.com/images/Uk3Fdpje_400x400.jpg" type="image/x-icon">
	<link rel="icon" href="https://raelize.com/images/Uk3Fdpje_400x400.jpg" type="image/x-icon">

	
	<!-- Global Site Tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-135892271-3"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-135892271-3');
	</script>
	

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>


<body id="body" data-spy="scroll" data-target=".navbar" data-offset="55">
  <div id="content">
    
 <section class="sticky-top navigation">
	<div class="container">
		<nav class="navbar navbar-expand-lg navbar-dark">
			<a class="navbar-brand p-0" href="/">
				
				<img class="lozad" data-src="https://raelize.com/images/logo.png" alt="Raelize - Embedded Device Security Services Consultancy Testing Research Training" height="42">
				
			</a>

			<button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation">
				<span class="navbar-toggler-icon"></span>
			</button>

			<div class="collapse navbar-collapse" id="navigation">
				<ul class="navbar-nav ml-auto">
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/about">about</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/#services">overview</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/training">training</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/consultancy">consultancy</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/testing">testing</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/publications">publications</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/blog">blog</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/resources">resources</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/#contact">contact</a>
					</li>
					
				</ul>
				
			</div>
		</nav>
	</div>
</section>


<section class="section">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 offset-lg-2 text-center">
                <hr />
                <h2>Qualcomm IPQ40xx: Achieving QSEE Code Execution</h2>
                
                <p>Monday, Jun 14, 2021</p>
                <hr />
                
            </div>
            <div class="col-lg-8 offset-lg-2">
                <div class="post-single-content" background-color="0xff"><p>In this post we finally dive into our approach for exploiting the vulnerabilities we&rsquo;ve identified in QSEE, Qualcomm&rsquo;s Trusted Execution Environment (TEE), on <a href="https://www.qualcomm.com/media/documents/files/ipq40x8-ipq40x9-product-brief.pdf">Qualcomm IPQ40xx</a>-based devices (see <a href="/blog/qualcomm-ipq40xx-an-unexpected-cup-of-tee/">post #1</a> and <a href="/blog/qualcomm-ipq40xx-analysis-of-critical-qsee-vulnerabilities/">post #2</a>). This allowed us to achieve arbitrary code execution in the context of QSEE.</p>
<p>Interestingly, the exploitation approach described in this post can also be used for the with the Electromagnetic Fault Injection (EMFI) attack we performed as well (see <a href="/blog/qualcomm-ipq40xx-breaking-into-qsee-using-fault-injection/">post #3</a>). This allows achieving code execution in absence of any software vulnerability.</p>
<h2 id="secure-ranges">Secure ranges</h2>
<hr>
<p>It&rsquo;s the responsibility of QSEE to check that input/output buffers passed by the REE do not overlap with secure memory. As we described in <a href="/blog/qualcomm-ipq40xx-analysis-of-critical-qsee-vulnerabilities/">post #2</a>, this is done using secure range checks.</p>
<p>The secure range table and its entries may vary between devices, as it depends on the memory layout of the device. The secure range table for our target is shown below. It contains 10 entries of which three are configured and enabled.</p>
<div style="text-align:center">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>                   ID        FLAGS        START        END    
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB1E0 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x00000002</span>, <span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x7FFFFFFF</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB1F0 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x00000002</span>, <span style="color:#ae81ff">0x90000000</span>, <span style="color:#ae81ff">0xFFFFFFFF</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB200 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000002</span>, <span style="color:#ae81ff">0x00000002</span>, <span style="color:#ae81ff">0x87E80000</span>, <span style="color:#ae81ff">0x87FFFFFF</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB210 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000003</span>, <span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x00000000</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB220 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000004</span>, <span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x00000000</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB230 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000005</span>, <span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x00000000</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB240 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000006</span>, <span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x00000000</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB250 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000007</span>, <span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x00000000</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB260 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000008</span>, <span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x00000000</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB270 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000009</span>, <span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x00000000</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB280 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0xFFFFFFFF</span>, <span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x00000000</span><span style="color:#f92672">&gt;</span>
</span></span></code></pre></div></div>
<p>The entire address space is covered (32-bit) by the secure ranges. With the above configuration, only the following non-secure memory ranges defined: <code>0x80000000 - 0x87E80000</code> and <code>0x88000000 - 0x90000000</code>. The rest is considered secure memory by the secure range check.</p>
<p>Other (hardware) TrustZone controllers (i.e. TZASC) ensure that the REE cannot access secure memory directly over the bus. The configuration of these controllers must be fully aligned with the defined secure ranges. Any discrepancy may allow the REE to access secure memory.</p>
<h4 id="open-sesame">Open Sesame</h4>
<p>The vulnerable SMC handler routines we identified were using the secure range check incorrectly (see <a href="/blog/qualcomm-ipq40xx-analysis-of-critical-qsee-vulnerabilities/">post #2</a>). This allows writing several restricted values values (i.e. <code>0</code>, <code>1</code> and <code>2</code>) to an arbitrary address (incl. secure memory). While these are interesting primitives, they are not sufficient to achieve arbitrary code execution directly.</p>
<p>We raelized that the unused secure range entries have the FLAGS field set to <code>0x00000001</code>. Interestingly, this field is checked by the secure range check function (i.e. <code>is_allowed_range</code>). If <code>bit 1</code> is set to <code>0</code>, the entry is actually skipped as is visible in the decompiled code shown below.</p>
<p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">is_allowed_range</span>(<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>sr_table, <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>start_addr, <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>end_addr)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>range_addr, range_start;
</span></span><span style="display:flex;"><span>    secure_range <span style="color:#f92672">*</span>sec_range;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( end_addr <span style="color:#f92672">&lt;</span> start_addr )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> ( <span style="color:#66d9ef">int</span> i <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; ; <span style="color:#f92672">++</span>i )                <span style="color:#75715e">// iterate over all entries
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    {
</span></span><span style="display:flex;"><span>        sec_range <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>sr_table[<span style="color:#ae81ff">4</span> <span style="color:#f92672">*</span> i];       <span style="color:#75715e">// get pointer to entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> ( sec_range<span style="color:#f92672">-&gt;</span>id <span style="color:#f92672">==</span> <span style="color:#ae81ff">0xFFFFFFFF</span> )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>(sec_range<span style="color:#f92672">-&gt;</span>flags <span style="color:#f92672">&amp;</span> <span style="color:#ae81ff">2</span>) )      <span style="color:#75715e">// check if range is enabled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>            <span style="color:#66d9ef">continue</span>;                       <span style="color:#75715e">// go to next entry
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>        range_addr <span style="color:#f92672">=</span> sec_range<span style="color:#f92672">-&gt;</span>end_addr;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>range_addr )
</span></span><span style="display:flex;"><span>        {
</span></span><span style="display:flex;"><span>            range_addr <span style="color:#f92672">=</span> sec_range<span style="color:#f92672">-&gt;</span>start_addr;
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ( range_addr <span style="color:#f92672">&lt;=</span> start_addr )
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>LABEL_10:
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> ( range_addr <span style="color:#f92672">&lt;=</span> end_addr )
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>            
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">continue</span>;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// check range
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        range_start <span style="color:#f92672">=</span> sec_range<span style="color:#f92672">-&gt;</span>start_addr;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( range_start <span style="color:#f92672">&lt;=</span> start_addr <span style="color:#f92672">&amp;&amp;</span> range_addr <span style="color:#f92672">&gt;</span> start_addr <span style="color:#f92672">||</span> range_start <span style="color:#f92672">&lt;=</span> end_addr <span style="color:#f92672">&amp;&amp;</span> range_addr <span style="color:#f92672">&gt;</span> end_addr )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> ( range_start <span style="color:#f92672">&gt;</span> start_addr )
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">goto</span> LABEL_10;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1</span>;                               <span style="color:#75715e">// range is allowed
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div></p>
<p>This means we are able to disable an entry in the secure range table if we are able to set <code>bit 1</code> of the flags field. As you likely raelize, we can use the restricted writes (i.e. <a href="https://www.qualcomm.com/company/product-security/bulletins/january-2021-bulletin#_cve-2020-11256">CVE-2020-11256</a>, <a href="https://www.qualcomm.com/company/product-security/bulletins/january-2021-bulletin#_cve-2020-11258">CVE-2020-11258</a> and <a href="https://www.qualcomm.com/company/product-security/bulletins/january-2021-bulletin#_cve-2020-11259">CVE-2020-11259</a>) for doing exactly that. For example, we can write <code>0x1</code> to the flags field of all the entries as is shown below.</p>
<div style="text-align:center">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB1E0 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x00000000</span>, <span style="color:#ae81ff">0x7FFFFFFF</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB1F0 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x90000000</span>, <span style="color:#ae81ff">0xFFFFFFFF</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>LOAD:<span style="color:#ae81ff">87</span>EAB200 <span style="color:#f92672">&lt;</span><span style="color:#ae81ff">0x00000002</span>, <span style="color:#ae81ff">0x00000001</span>, <span style="color:#ae81ff">0x87E80000</span>, <span style="color:#ae81ff">0x87FFFFFF</span><span style="color:#f92672">&gt;</span>
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div></div>
<p>Once all secure ranges are disabled, the secure range checks performed by all the SMC handler routines will consider any physical address (incl. secure memory) to be allowed. This opens up a completely new attack surface as the behavior of the other SMC handlers can now be used for our own advantage.</p>
<p>Differently said, by removing the restrictions enforced by the secure range checks, we made all SMC handler routines vulnerable in a very similar fashion as the software vulnerabilities we identified.</p>
<h2 id="findings-new-primitives">Findings new primitives</h2>
<hr>
<p>After removing the restrictions enforced by the secure range checks, we were presented with a variety of possibilities. We immediately started foraging for more powerful <strong>Read</strong>, <strong>Write</strong> and <strong>Execution</strong> primitives. Better primitives should bring us closer to achieving arbitrary QSEE code execution.</p>
<h4 id="write-primitive">Write primitive</h4>
<p>The SMC handler routine <code>tzbsp_pil_get_mem_area</code> calls the <code>get_mem_area</code> function with <code>arg2</code> as is shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tzbsp_pil_get_mem_area</span>(<span style="color:#66d9ef">int</span> arg1, <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>arg2, <span style="color:#66d9ef">uint32_t</span> arg3)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( arg3 <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">8</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0xFFFFFFF0</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// this secure range check is disabled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ( is_non_sec_mem(arg2, <span style="color:#ae81ff">8</span>) )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> get_mem_area(arg2, arg2 <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0xFFFFFFEE</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>get_mem_area</code> writes <code>0x80000000</code> and <code>0xA0000000</code> to an address provided by the REE by dereferencing the pointer contained in <code>arg2</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">get_mem_area</span>(<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>a1, <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>a2) 
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>a1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x80000000</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#f92672">*</span>a2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0xA0000000</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>is_non_sec_mem</code> function returns always <code>1</code> as all secure ranges are disabled. Therefore, we can write <code>0x80000000</code> and <code>0xA0000000</code> to any address (incl. secure memory). This adds two more restricted writes collection of restricted writes.</p>
<h4 id="readwrite-primitive">Read/Write primitive</h4>
<p>The SMC handler routine <code>tzbsp_get_diag</code> copies the diagnostics information buffer to an address that&rsquo;s provided by the REE. The source address (i.e. <code>0x87FDF000</code>), which we named <code>diag_info_buf_ptr</code>, is actually a pointer stored in a writable location in secure memory.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tzbsp_get_diag</span>(<span style="color:#66d9ef">uint8_t</span> <span style="color:#f92672">*</span>addr, size_t size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( size <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">0x1000</span> )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0xFFFFFFEF</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// this secure range check is disabled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ( addr <span style="color:#f92672">&gt;</span> <span style="color:#f92672">~</span>size <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>is_allowed_range(sr_table, addr, <span style="color:#f92672">&amp;</span>addr[size <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>]) )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0xFFFFFFEE</span>;
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// copy from diag_info_buf_ptr to dst_addr
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    memcpy(addr, diag_info_buf_ptr, <span style="color:#ae81ff">0x1000u</span>);
</span></span><span style="display:flex;"><span>    tzbsp_dcache_clean_inval_region(addr, <span style="color:#ae81ff">0x1000</span>);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>We can write the contents of the diagnostics information buffer to any address as we control <code>addr</code> and the secure ranges are disabled.</p>
<p>We can use the previously described <strong>Write</strong> primitive to overwrite <code>diag_info_buf_ptr</code> with <code>0x80000000</code>. As this address points to non-secure memory, we control the data stored at this address. This allows us to write arbitrary data to an arbitrary address.</p>
<p>Then, we can use this arbitrary <strong>Write</strong> primitive to overwrite <code>diag_info_buf_ptr</code> with an arbitrary value. This allows us to write read from an arbitrary address.</p>
<p>The downside of this <strong>Read/Write</strong> primitive is that it always copies <code>0x1000</code> bytes. Another inconvenience is that we cannot read the initial value of (<code>diag_info_buf_ptr</code>) as arbitrary reads are only possible after the <strong>Write</strong> primitive is obtained. This means we cannot restore the original value if needed.</p>
<h4 id="execution-primitive">Execution primitive</h4>
<p>The SMC handler routine <code>tzbsp_exec_smc</code> calls the function <code>exec_smc_wrapper</code> with arguments passed by the REE as is shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">tzbsp_exec_smc</span>(<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> addr1, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> addr2, <span style="color:#66d9ef">int</span> size2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( addr2 <span style="color:#f92672">&gt;=</span> addr1 )
</span></span><span style="display:flex;"><span>    {
</span></span><span style="display:flex;"><span>        exec_smc_wrapper(addr1, addr2 <span style="color:#f92672">-</span> addr1 <span style="color:#f92672">-</span> <span style="color:#ae81ff">0xC</span>, addr2, size2);
</span></span><span style="display:flex;"><span>        JUMPOUT(locret_87E88636);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0xFFFFFFF0</span>;
</span></span></code></pre></div><p>The <code>exec_smc_wrapper</code> function calls <code>exec_smc</code> with the arguments received from the REE. Note, not all arguments are fully under REE control as <code>size1</code> is computed (i.e. <code>addr2 - addr1 - 0xC</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">exec_smc_wrapper</span>(<span style="color:#66d9ef">int</span> addr1, <span style="color:#66d9ef">int</span> size1, <span style="color:#66d9ef">int</span> addr2, <span style="color:#66d9ef">int</span> size2)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> exec_smc(addr1, size1, addr2, size2, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The <code>exec_smc</code> function performs two checks on the arguments passed by the REE using the <code>is_non_sec_mem</code>. Then, once all checks are passed, it retrieves a function pointer from a table in memory (<code>smc_exec_func_ptr_tbl</code>) and calls it with the arguments passed by the REE.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">int</span> <span style="color:#a6e22e">exec_smc</span>(<span style="color:#66d9ef">int</span> addr1, <span style="color:#66d9ef">int</span> size1, <span style="color:#66d9ef">int</span> addr2, <span style="color:#66d9ef">int</span> size2, <span style="color:#66d9ef">int</span> idx)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> (<span style="color:#66d9ef">__fastcall</span> <span style="color:#f92672">*</span>smc_func_ptr)(<span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>, <span style="color:#66d9ef">int</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// these secure range checks are disabled
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ( <span style="color:#f92672">!</span>is_non_sec_mem(addr1, size1) <span style="color:#f92672">||</span> <span style="color:#f92672">!</span>is_non_sec_mem(addr2, size2) )
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0xFFFFFFEE</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// retrieve function pointer from secure
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    smc_func_ptr <span style="color:#f92672">=</span> smc_exec_func_ptr_tbl[<span style="color:#ae81ff">5</span> <span style="color:#f92672">*</span> idx];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// if function pointer is not zero, call the function pointer
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> ( smc_func_ptr )
</span></span><span style="display:flex;"><span>        smc_func_ptr(addr1, size1, addr2, size2);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The function pointer is stored in a writable location in secure memory and therefore we can overwrite it with an arbitrary value using our <strong>Read/Write</strong> primitive. This allows us to make the processor execute code from any address.</p>
<h2 id="returning-to-qsee">Returning-to-QSEE</h2>
<hr>
<p>We have many ingredients, we can read from anywhere, we can write to anywhere and we can make the processor jump to any location, let&rsquo;s start cooking. As a first step, we&rsquo;ve decided to use our newly acquired primitives to return to the QSEE software itself.</p>
<h4 id="jumping-anywhere">Jumping anywhere</h4>
<p>Our goal is to overwrite the function pointer used by <code>tzbsp_exec_smc</code> with an arbitrary value. We accomplished this by combining multiple primitives together.</p>
<ol>
<li>Call <code>tzbsp_pil_get_memory_area</code> to overwrite <code>tzbsp_get_diag</code>&rsquo;s source address with <code>0x80000000</code> which is non-secure memory.</li>
<li>Copy our target pointer to be executed to address <code>0x80000000</code> from the REE.</li>
<li>Call <code>tzbsp_get_diag</code> to overwrite <code>tzbsp_exec_smc</code>&rsquo;s function pointer table with the target pointer.</li>
<li>Call <code>tzbsp_exec_smc</code> to jump to any address within the QSEE software.</li>
</ol>
<p>Whoop Whoop! Well, let&rsquo;s not celebrate too soon. We can only reuse QSEE code that&rsquo;s already present inside the device. We can call e.g. specific functions or gadgets. Quite interesting, but not exactly arbitrary code execution.</p>
<h4 id="improved-readwrite-primitive">Improved Read/Write primitive</h4>
<p>Nonetheless, let&rsquo;s use it for something useful. The <strong>Read/Write</strong> primitive described earlier in this post is not optimal as it always copies 0x1000 bytes and its source pointer must be adjusted constantly. Therefore, we decided to use our newly acquired return-to-QSEE capabilities to create a RW-primitive that we fully control.</p>
<p>We identified the presence of a hardened <code>memcpy</code> implementation which we named <code>secure_memcpy</code>. As is common practice, it&rsquo;s actually a wrapper around an actual <code>memcpy</code> function as is shown below.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#66d9ef">uint32_t</span> <span style="color:#a6e22e">secure_memcpy</span>(<span style="color:#66d9ef">int</span> dst, <span style="color:#66d9ef">uint32_t</span> dst_size, <span style="color:#66d9ef">int</span> src, <span style="color:#66d9ef">uint32_t</span> src_size)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">if</span> ( dst_size <span style="color:#f92672">&gt;</span> src_size )
</span></span><span style="display:flex;"><span>    dst_size <span style="color:#f92672">=</span> src_size;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">else</span>
</span></span><span style="display:flex;"><span>    dst_size <span style="color:#f92672">=</span> dst_size;
</span></span><span style="display:flex;"><span>  
</span></span><span style="display:flex;"><span>  memcpy(dst, src, dst_size);
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> dst_size;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Why is this useful? Well, we can use our return-to-QSEE capabilities to call any function, including the <code>secure_memcpy</code> function. Ideally, we would call the <code>memcpy</code> function directly, but we do not control all arguments. We actually only control <code>r0</code>, <code>r2</code> and <code>r3</code>. Luckily, the <code>secure_memcpy</code> function uses exactly these arguments as arguments for calling the <code>memcpy</code> function. This allows us to leverage the <code>secure_memcpy</code> function to call the <code>memcpy</code> function with arbitrary arguments in order to create a very efficient <strong>Read/Write</strong> primitive.</p>
<h2 id="executing-shellcode">Executing shellcode</h2>
<hr>
<p>The classical approach would be to write a shellcode in QSEE memory ensure the memory is also executable and then trigger execution. But we actually prefer a slightly more effective approach that practically works in many real cases: store the shellcode in non-secure memory, that we already control and have QSEE execute it from there. This allows very easy shaping of our payloads.</p>
<p>We tried this strategy, but we quickly figured out that something prevented our shellcode from executing. The MMU is actually correctly configured to prevent the processor to execute from non-secure pages when it&rsquo;s in the secure state (i.e. the XN-bit is correctly used). Therefore, we needed to circumvent the limitations of the MMU in to order achieve arbitrary code execution.</p>
<h4 id="patching-the-mmu-configuration">Patching the MMU configuration</h4>
<p>The Translation Table Base Register 0, <code>TTBR0</code> register, stores the base address for the L1 translation table. The size of this primary page table is 16 KB and its base is set to <code>0x87EDC000</code> for the device we are analyzing. We&rsquo;ve recovered this address by reverse engineering the QSEE initialization routines.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>...                                                   
</span></span><span style="display:flex;"><span>LOAD:87E8B520 90 00 9F E5   LDR    R0, =dword_87EDC000
</span></span><span style="display:flex;"><span>LOAD:87E8B524 D9 E2 FF EB   BL     set_TTBR0
</span></span><span style="display:flex;"><span>...                                                   
</span></span></code></pre></div><p>We used our arbitrary <strong>Read/Write</strong> primitive to dump the entire L1 translation table. This table includes 4096 entries of 4 bytes that describe the entire 32-bit virtual address space in 1 MB chunks. Each entry can be set as <strong>Invalid</strong>, <strong>Page table</strong>, <strong>Section</strong>, <strong>Supersection</strong> or <strong>Reserved</strong>.</p>
<p>For the device we analyzed, the L1 translation table only included <strong>Section</strong> and <strong>Page table</strong> entries. A <strong>Section</strong> entry covers an entire 1 MB region. A <strong>Page table</strong> entry points to a L2 translation table that includes 256 entries to cover the 1 MB region in 4 KB chunks. The entire virtual address spaces is mapped to the physical address space using a 1-to-1 mapping. Several entries are shown in the snippet below.</p>
<div style="text-align:center">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>...                                                            
</span></span><span style="display:flex;"><span>0x87edc000:     01 a0 eb 87 01 a4 eb 87 16 04 21 00 16 04 31 00
</span></span><span style="display:flex;"><span>0x87edc010:     16 04 41 00 16 04 51 00 16 04 61 00 16 04 71 00
</span></span><span style="display:flex;"><span>...                                                            
</span></span><span style="display:flex;"><span>0x87edffe0      16 04 81 ff 16 04 91 ff 16 04 a1 ff 16 04 b1 ff
</span></span><span style="display:flex;"><span>0x87edfff0      16 04 c1 ff 16 04 d1 ff 16 04 e1 ff 16 04 f1 ff
</span></span><span style="display:flex;"><span>...                                                            
</span></span></code></pre></div></div>
<p>As the page tables are not easily digested by the human brain, we wrote a translation table parser in order to make sense out of the MMU configuration. The non-secure memory is configured using <strong>Section</strong> entries in the L1 page table for which the format is shown in the picture below.</p>
<p style="text-align:center;">
    <a href="/img/ipq40xx/mmu_section.png">
        <img src="/img/ipq40xx/mmu_section.png" style="max-width: 90%">
    </a>
</p>
<p>A representation of the <strong>Section</strong> entry for address <code>0x82000000</code> (i.e. non-secure memory) obtained from our parser is shown below. It shows the 1-to-1 mapping and the configuration bits that are set for that 1 MB chunk of memory.</p>
<div style="text-align:center">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>VA[0x82000000] --&gt; PA[0x82000000] Domain: 0 NS: 0 AP: 001 XN: 1 PXN: 0
</span></span></code></pre></div></div>
<p>The XN-bit (i.e. <code>bit 4</code>) is set to <code>1</code>, which means an exception will be raised by the MMU if the processor tries to execute from that chunk of memory. The entire non-secure memory range has the XN-bit set in QSEE MMU configuration. This is <em>THE</em> reason we cannot execute from non-secure memory.</p>
<p>We decided to set the XN-bit to <code>0</code> in the <strong>Section</strong> entry of the L1 translation table for address <code>0x82000000</code> using our arbitrary <strong>Read/Write</strong> primitive. This allows us to store a shellcode in non-secure memory and execute it with QSEE privileges using our execution primitive.</p>
<div style="text-align:center">
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>Old: VA[0x82000000]: Section ----&gt; PA[0x82000000] Domain: 0 NS: 0 AP: 001 XN: 1 PXN: 0
</span></span><span style="display:flex;"><span>New: VA[0x82000000]: Section ----&gt; PA[0x82000000] Domain: 0 NS: 0 AP: 001 XN: 0 PXN: 0
</span></span></code></pre></div></div>
<h4 id="executing-the-shellcode">Executing the shellcode</h4>
<p>The shellcode, we store at address <code>0x82000000</code> (non-secure memory), reads the Secure Configuration Register (SCR), which contains the NS-bit. If the read-out NS-bit is set to <code>0</code> code execution is being performed with QSEE privileges. This allows us to determine if the exploit works as expected.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C++" data-lang="C++"><span style="display:flex;"><span><span style="color:#ae81ff">0x00</span><span style="color:#f92672">:</span>  <span style="color:#ae81ff">11</span> <span style="color:#ae81ff">1F</span> <span style="color:#ae81ff">11</span> EE    mrc p15, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>, r1, c1, c1, <span style="color:#960050;background-color:#1e0010">#</span><span style="color:#ae81ff">0</span>   <span style="color:#75715e">// read SCR into R1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">0x04</span><span style="color:#f92672">:</span>  <span style="color:#ae81ff">00</span> <span style="color:#ae81ff">10</span> <span style="color:#ae81ff">80</span> E5    str r1, [r0]                  <span style="color:#75715e">// store R1 at [R0]
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span><span style="color:#ae81ff">0x08</span><span style="color:#f92672">:</span>  <span style="color:#ae81ff">1</span>E FF <span style="color:#ae81ff">2F</span> E1    bx  lr                        <span style="color:#75715e">// return
</span></span></span></code></pre></div><p>We take the following steps to execute the shellcode:</p>
<ul>
<li>Store shellcode at <code>0x82000000</code> in non-secure memory</li>
<li>Disable the secure ranges using <a href="/blog/qualcomm-ipq40xx-analysis-of-critical-qsee-vulnerabilities/#cve-2020-11256-tzbsp_blow_fuses_and_reset">CVE-2020-11256</a></li>
<li>Create our <a href="/blog/qualcomm-ipq40xx-achieving-qsee-code-execution/#rw-primitive">Read/Write primitive</a> using the <code>secure_memcpy</code> function</li>
<li>Use this primitive to <a href="/blog/qualcomm-ipq40xx-achieving-qsee-code-execution/#patching-the-mmu-configuration">patch the L1 translation table entry</a> for <code>0x82000000</code></li>
<li>Jump to <code>0x82000000</code> using our <a href="/blog/qualcomm-ipq40xx-achieving-qsee-code-execution/#execution-primitive">execution primitive</a> to achieve arbitrary code execution</li>
</ul>
<p>The video below demonstrates the complete exploit.</p>
<center>
<iframe src="https://player.vimeo.com/video/512501383" width="640" height="360" frameborder="0" allow="autoplay; fullscreen; picture-in-picture" allowfullscreen></iframe>
</center>
<br>
<p>Note, disabling the secure ranges can also be accomplished using the hardware EMFI attack that we described in <a href="/blog/qualcomm-ipq40xx-breaking-into-qsee-using-fault-injection/">post #3</a>. This shows that software exploitation knowledge can be reused efficiently for fault injection attacks. Differently said, exploits made for software vulnerabilities that are already fixed can be reused.</p>
<h2 id="conclusion">Conclusion</h2>
<hr>
<p>The vulnerabilities we identified in QSEE allowed us to write several restricted values to secure memory. This enabled us to disable the secure range checks in order to open up a larger attack surface that we used to achieve arbitrary code execution.</p>
<p>This reminds us of an old adage that any secure system is really only as strong as its weakest link. If the software is vulnerable, the ARM TrustZone hardware primitives provide little protection. Moreover, the enforcement of the security boundary between the REE and QSEE is for a significant part implemented in software.</p>
<p>It&rsquo;s worth noting that the use of secure range checks is not uncommon. Actually, any privileged subsystem receiving arguments (i.e. pointers) from a non-trusted subsystem must implement some form of sanitation in line with the current secure memory layout. Therefore, the exploitation strategy that we used may be applicable to other TEEs as well.</p>
<p>The ability to reconfigure the QSEE subsystem provides ample opportunities to an attacker. As demonstrated in this research, a restricted write due to a software vulnerability may compromise the entire QSEE subsystem.</p>
<p>Locking the configuration until next reset would obviously address this issue. However, this is only possible for long-lived configuration options that do not need any changes at runtime. For example, most devices dynamically reuse memory as secure and non-secure for implementing various use cases efficiently. Therefore, several configurations can simply not be fully locked.</p>
<p>Interesting solutions include verifying the integrity of the configured secure range tables. For our approach, a simple checksum would have likely been sufficient to prevent the modification of the secure range table, as we only had the ability to write restricted values.</p>
<h2 id="final-words">Final words</h2>
<hr>
<p>This post concludes our research on QSEE, Qualcomm&rsquo;s Trusted Execution Environment (TEE), on Qualcomm IPQ40xx-based devices. We like to thank Qualcomm for professionally handling the disclosure and their attitude towards us as security researchers.</p>
<p>- Raelize<span style="color:yellow">.</span></p>
</div>
                

                
                
            </div>
        </div>
    </div>
</section>


  </div><!-- end Contact Area -->
<footer id="footer" class="section-bg">
	<div class="container">
		<div class="row wow fadeInUp" data-wow-duration="500ms">
			<div class="col-xl-12">

				<!-- Footer Social Links -->
				<div class="social-icon">
					<ul class="list-inline">
						
						<li class="list-inline-item"><a href="https://twitter.com/raelizecom" rel="nofollow"><i class="ti-twitter-alt"></i></a></li>
						
						<li class="list-inline-item"><a href="https://www.linkedin.com/company/raelize" rel="nofollow"><i class="ti-linkedin"></i></a></li>
						
					</ul>
				</div>

				<!-- copyright -->
				<div class="copyright text-center">
					<a href="https://raelize.com/">
						<img src="https://raelize.com/images/logo.png" alt="Raelize - Embedded Device Security Services Consultancy Testing Research Training" height="42" />
					</a>
					<br>
					<p>Copyright ©2020 Raelize B.V. <br> Powered by <a href=#>Hugo</a> and <a href="https://themefisher.com">Themefisher</a>.</p>
				</div>
			</div>
		</div>
	</div>
</footer>
<!-- /footer -->

<!-- Google Map API -->


<!-- JS Plugins -->

<script src="https://raelize.com/plugins/jquery/jquery.min.js"></script>

<script src="https://raelize.com/plugins/bootstrap/bootstrap.min.js"></script>

<script src="https://raelize.com/plugins/slick/slick.min.js"></script>

<script src="https://raelize.com/plugins/shuffle/shuffle.min.js"></script>

<script src="https://raelize.com/plugins/magnific-popup/jquery.magnific-popup.min.js"></script>

<script src="https://raelize.com/plugins/lazy-load/lozad.min.js"></script>

<script src="https://raelize.com/plugins/google-map/map.js"></script>


<!-- Main Script -->

<script src="https://raelize.com/js/script.min.30c5d71cc6d4427af95614c557ab5b3e327ad2aa865d9c4cb3e3af601bd051948abde36c96cad1b4cb71909318d0e18c.js" integrity="sha384-MMXXHMbUQnr5VhTFV6tbPjJ60qqGXZxMs&#43;OvYBvQUZSKveNslsrRtMtxkJMY0OGM"></script>


</body>

</html>
